# Выполняем инициализацию
(Команда git init создает репозиторий — директорию .git, которая содержит все необходимые для работы git файлы.)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
hexlet-git$ git init
Initialized empty Git repository in /private/tmp/hexlet-git/.git/
…or create a new repository on the command line
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
echo "# hexlet-git" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin git@github.com:LotoNairo/hexlet-git.git
git push -u origin main

…or push an existing repository from the command line

git remote add origin git@github.com:LotoNairo/hexlet-git.git
git branch -M main
git push -u origin main

…or import code from another repository

You can initialize this repository with code from a Subversion, Mercurial, or TFS project.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
git pull --rebase
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Клонирование
$ git clone git@github.com:<ИМЯ НА ГИТХАБЕ>/hexlet-git.git
$ cd hexlet-git
$ ls -la
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
hexlet-git$ git rm PEOPLE.md
# равносильно rm + git add
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
git diff, которая показывает разницу между тем, что было и что стало:
# Выведет все изменения сделанные в рабочей директории
# которые были добавлены в индекс
hexlet-git$ git diff --stage
 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 git log 
 Она показывает список всех выполненных коммитов, отсортированных по дате добавления
 У команды git log есть полезный флаг -p, который сразу выводит диф для каждого коммита.
 git log --oneline ---показывает сокращенный вызов
 git log --graph --- вывод в виде со вязью между коммитами(последовательностью)
 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 У каждого коммита есть идентификатор (говорят "хеш"), уникальный набор символов. С помощью хеша можно посмотреть все изменения, сделанные в рамках одного коммита:
 hexlet-git$ git show 5120bea3e5528c29f8d1da43731cbe895892eb6d (можно толко первые 8 символов)
 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 git blame <путь до файла>
 Эта команда выводит файл и рядом с каждой строкой показывает того, кто её менял и в каком коммите.
 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 git grep "line"
 Команда git grep ищет совпадение с указанной строкой во всех файлах проекта. Это очень удобная команда для быстрого анализа из терминала. 
 Она удобнее обычного grep, так как знает про игнорирование и не смотрит в директорию .git, а ещё умеет искать по истории.
 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 # Выполняем очистку
 # -f – force, -d – directory
 hexlet-git$ git clean -fd
 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 Для отмены изменений в таких файлах используется команда git restore. --- git restore <file>
 Перевод изменений из индекса в рабочую директорию --- git restore --staged INFO.md
 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 Создание одного коммита, который выполняет изменения противоположные тому коммиту, который отменяется.
 git revert aa600a43cb164408e4ad87d216bc679d097f1a6c
 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 Удаление коммита.Если этот коммит сделан был только сейчас и ещё не отправлялся на Github, то лучше сделать так, 
 как будто бы этого коммита не существовало в принципе. --- git reset --hard HEAD~
 Флаг --hard это полное удаление вместо простой отмены и помещения всех изменений коммита в рабочую директорию.
 HEAD~ означает один коммит от последнего коммита, если HEAD~2 то удалит 2 последних коммита
 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 Ести понял что не все добавил в последний коммит,то оставшуюся часть изменений можно дослать следующим коммитом либо, 
 если изменения ещё не были отправлены во внешнюю систему, можно добавить изменения в текущий коммит. Для этого во время коммита добавляется флаг --amend:
 git commit --amend
 В реальности --amend не добавляет изменения в существующий коммит, этот флаг приводит к откату коммита (через reset) и выполнению нового коммита с новыми данными. 
 Поэтому мы и видим ровно один коммит, хотя команда git commit выполнялась два раза (первый раз — когда сделали ошибочный коммит).
 Для того, чтобы не открывался редактор для ввода описания коммита к команде git commit --amend можно добавить опцию --no-edit. В этом случае описание коммита не изменится.
 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 git commit INFO.md -m 'update INFO.md'
 # Флаг -a автоматически добавляет все изменения рабочей директории в индекс
 git commit -am 'do something'
 git add -i -позволяет изменять куски файлов
 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 Git позволяет не только просматривать историю, но и перемещаться по ней, загружая в рабочую директорию состояние кода на момент выполнения любого коммита.
 git checkout <хеш коммита>: перемещение на коммит с данным индексом
 hexlet-git$ git checkout main --- возврат на последний коммит
 git branch --- показывает где мы сейчас находимся.
 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 Git позволяет гибко настраивать игнорирование определенных файлов и директорий. Делается это с помощью файла .gitignore:
 # В этом файле можно оставлять комментарии
# Каждая строчка — это шаблон, по которому происходит игнорирование

# Игнорируется файл в любой директории проекта
access.log

# Игнорируется директория в любой директории проекта
node_modules

# Игнорируется директория в корне git-репозитория
/coverage

# Игнорируются все файлы с расширением sqlite3 в директории db,
# но не игнорируются такие же файлы внутри любого вложенного каталога в db
# например, /db/something/lala.sqlite3
/db/*.sqlite3

# игнорировать все .txt файлы в каталоге doc/
# на всех уровнях вложенности
doc/**/*.txt
Как только в проект добавляется файл .gitignore, то он сразу начинает работать. Все новые файлы, попадающие под игнорирование, 
не отобразятся в выводе команды git status. Файл .gitignore также следует выгружать в удалённый репозиторий, например, на Github.
 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 В git существует набор команд, позволяющий «прятать» изменения в рабочей директории (от коммита) и восстанавливать их при необходимости.
 Прячем файлы. После этой команды пропадут все изменённые файлы независимо от того, добавлены они в индекс или нет :
 hexlet-git$ git stash //прячем
 hexlet-git$ git stash pop //восстанавлваем
 Stash в Git работает по принципу стека. Он позволяет сохранить внутрь любое количество изменений и восстановить их в обратном порядке:
 $ git stash
# изменяем файлы
$ git stash
# Вернутся последние изменения
$ git stash pop
# Вернутся предпоследние изменения
$ git stash pop
 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 
